import tkinter as tk
from tkinter import filedialog, messagebox
import hashlib
from Crypto.Cipher import ChaCha20
from Crypto.Random import get_random_bytes

# --- Core I/O and Cryptographic Functions from Section 3 ---

def read_binary_file(file_path):
    """Reads the entire content of a file in binary mode."""
    with open(file_path, 'rb') as f:
        return f.read()

def write_binary_file(file_path, data):
    """Writes a bytes object to a file in binary mode."""
    with open(file_path, 'wb') as f:
        f.write(data)

def encrypt_image(file_path, key, output_path):
    """Encrypts a file using ChaCha20 and saves it."""
    plaintext = read_binary_file(file_path)
    nonce = get_random_bytes(12)
    cipher = ChaCha20.new(key=key, nonce=nonce)
    ciphertext = cipher.encrypt(plaintext)
    encrypted_data = nonce + ciphertext
    write_binary_file(output_path, encrypted_data)

def decrypt_image(encrypted_file_path, key, output_path):
    """Decrypts a file encrypted with ChaCha20 and saves it."""
    encrypted_data = read_binary_file(encrypted_file_path)
    nonce = encrypted_data[:12]
    ciphertext = encrypted_data[12:]
    cipher = ChaCha20.new(key=key, nonce=nonce)
    decrypted_data = cipher.decrypt(ciphertext)
    write_binary_file(output_path, decrypted_data)

# --- GUI Application Class ---

class CryptoApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Image Encryptor/Decryptor")
        self.root.geometry("550x150")
        self.root.resizable(False, False)

        # --- State Variables ---
        self.file_path = tk.StringVar()
        self.key = tk.StringVar()
        self.status_text = tk.StringVar()

        # --- Layout Frames ---
        file_frame = tk.Frame(self.root, padx=10, pady=10)
        file_frame.pack(fill="x")

        key_frame = tk.Frame(self.root, padx=10, pady=10)
        key_frame.pack(fill="x")

        status_frame = tk.Frame(self.root, padx=10, pady=10)
        status_frame.pack(fill="x", side="bottom")

        # --- File Selection Widgets ---
        tk.Label(file_frame, text="Input File:").pack(side="left")
        tk.Label(file_frame, textvariable=self.file_path, relief="sunken", width=45, anchor="w").pack(side="left", fill="x", expand=True, padx=5)
        tk.Button(file_frame, text="Browse...", command=self.browse_file).pack(side="left")

        # --- Key and Action Widgets ---
        tk.Label(key_frame, text="Secret Key:").pack(side="left")
        tk.Entry(key_frame, textvariable=self.key, show="*", width=35).pack(side="left", padx=5)
        tk.Button(key_frame, text="Encrypt", command=self.encrypt_action, width=10).pack(side="left", padx=2)
        tk.Button(key_frame, text="Decrypt", command=self.decrypt_action, width=10).pack(side="left")

        # --- Status Widget ---
        self.status_label = tk.Label(status_frame, textvariable=self.status_text)
        self.status_label.pack(fill="x")

    def _derive_key(self):
        """Derives a 32-byte key from the user's password using SHA-256."""
        password = self.key.get()
        return hashlib.sha256(password.encode()).digest()

    def browse_file(self):
        """Opens a file dialog to select an input file."""
        path = filedialog.askopenfilename()
        if path:
            self.file_path.set(path)
            self.status_text.set(f"Selected: {path.split('/')[-1]}")
            self.status_label.config(fg="black")

    def _validate_inputs(self):
        """Checks if both file path and key are provided."""
        if not self.file_path.get():
            messagebox.showerror("Error", "Please select an input file.")
            return False
        if not self.key.get():
            messagebox.showerror("Error", "Please enter a secret key.")
            return False
        return True

    def encrypt_action(self):
        """Callback for the Encrypt button."""
        if not self._validate_inputs():
            return

        output_path = filedialog.asksaveasfilename(defaultextension=".enc", filetypes=[("Encrypted Files", "*.enc")])
        if not output_path:
            return

        try:
            derived_key = self._derive_key()
            encrypt_image(self.file_path.get(), derived_key, output_path)
            self.status_text.set("Encryption successful!")
            self.status_label.config(fg="green")
            messagebox.showinfo("Success", f"File encrypted and saved to:\n{output_path}")
        except Exception as e:
            self.status_text.set(f"Error during encryption: {e}")
            self.status_label.config(fg="red")
            messagebox.showerror("Encryption Failed", f"An error occurred: {e}")

    def decrypt_action(self):
        """Callback for the Decrypt button."""
        if not self._validate_inputs():
            return

        output_path = filedialog.asksaveasfilename(defaultextension=".jpg", filetypes=[("JPEG files", "*.jpg"), ("PNG files", "*.png"), ("All files", "*.*")])
        if not output_path:
            return

        try:
            derived_key = self._derive_key()
            decrypt_image(self.file_path.get(), derived_key, output_path)
            self.status_text.set("Decryption successful!")
            self.status_label.config(fg="green")
            messagebox.showinfo("Success", f"File decrypted and saved to:\n{output_path}")
        except Exception as e:
            # Provide a generic error for security
            self.status_text.set("Error: Decryption failed. Check key and file.")
            self.status_label.config(fg="red")
            messagebox.showerror("Decryption Failed", "Decryption failed. The key may be incorrect or the file may be corrupted.")

if __name__ == '__main__':
    main_window = tk.Tk()
    app = CryptoApp(main_window)
    main_window.mainloop()